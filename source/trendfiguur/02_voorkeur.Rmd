# Voorkeur van de deelnemers

In dit hoofstuk gaan we vraag per vraag na welke voorkeur de deelnemers aangaven.

## Index of wijziging ten opzichte van referentie

De eerste aanpassingsmogelijkheid die we de deelnemers aanboden, betrof de Y-as.
De deelnemer moest kiezen tussen "index" of "procentuele wijziging".
Bij "index" vermenigvuldigen we alle waarden met dezelfde constante zodat de waarde voor het referentiejaar gelijk is aan 100.
Bij "procentuele wijziging" berekenen we procentuele wijziging ten opzichte van het referentiejaar.
De wijziging van het referentiejaar ten opzichte van zichzelf in dan uiteraard per definitie +0%.
In figuur \@ref(fig:y-as) tonen we beide figuren naast elkaar.

```{r y-as, fig.cap = "Keuzemogelijkheden voor de Y-as."}
set.seed(20230811)
ds <- generate_data(size = "strong")
create_figure(dataset = ds) |>
  grid.arrange(
    create_figure(dataset = ds, y_label = "change"), nrow = 1
  )
```

```{r y-as-type}
reference |>
  inner_join(background, by = "id") |>
  mutate(
    `Y-as` = .data$index, index = as.integer(.data$`Y-as` == "index")
  ) -> ds_referentie
ds_referentie |>
  count(.data$`Y-as`, .data$type, name = "aantal") |>
  pivot_wider(
    names_from = "type", names_sort = TRUE, values_from = "aantal",
    values_fill = list(aantal = 0)
  ) %>%
  bind_rows(
    summarise(
      ., across(-"Y-as", sum), across("Y-as", ~"totaal")
    )
  ) %>%
  bind_cols(
    select(., -"Y-as") %>%
      transmute(totaal = pmap_dbl(., sum))
  ) |>
  kbl(
    caption = "Voorkeur voor schaal Y-as per type deelnemer.", align = "lrrr",
    booktabs = TRUE
  ) |>
  row_spec(2, hline_after = TRUE) |>
  row_spec(3, bold = TRUE) |>
  column_spec(5, bold = TRUE)
```

```{r y-as-model}
tribble(
  ~"typeweinig vertrouwd", ~"typeenkel cijfers", ~"typebeide",
  1, -1,  0,
  1,  0, -1,
  0,  1, -1,
  1 / 3, 1 / 3, 1 / 3
) |>
  inla.make.lincombs() |>
  setNames(
    c("weinig vs cijfers", "weinig vs beide", "cijfers vs beide", "gemiddelde")
  ) -> lc
m_0 <- inla(
  index ~ 1, family = "binomial", data = ds_referentie,
  control.compute = list(waic = TRUE)
)
m_index <- inla(
  index ~ 0 + type, family = "binomial", data = ds_referentie, lincomb = lc,
  control.compute = list(waic = TRUE)
)
delta_waic <- m_0$waic$waic - m_index$waic$waic
```

Op basis van de ruwe data (tabel \@ref(tab:y-as-type)) stellen we over het algemeen een voorkeur vast voor een index.
De voorkeur verschilt naargelang het type deelnemer (\@ref(fig:fig-y-as-type)).
Deelnemers uit de groep "beide" hebben een lichte voorkeur voor een index.
Deze uit de groep "enkel cijfers" hebben mogelijk een voorkeur voor een index.
Terwijl de groep "weinig vertrouwd" een voorkeur hebben voor een index.
Merk dat de breedte van de intervallen samenhangen met het aantal deelnemers in elke groep.

```{r fig-y-as-type, fig.cap = "Kans dat een deelnemer Y-as met index verkiest boven een procentuele wijziging, opgesplitst per type deelnemer."}
m_index$summary.fixed |>
  rownames_to_column("type") |>
  mutate(
    type = str_remove(.data$type, "type")
  ) |>
  bind_rows(
    m_index$summary.lincomb.derived |>
      rownames_to_column(var = "type") |>
      filter(.data$type == "gemiddelde")
  ) |>
  mutate(
    type = factor(.data$type, levels = c("gemiddelde", levels(background$type)))
  ) |>
  ggplot(
    aes(
      x = plogis(mean), xmin = plogis(`0.025quant`),
      xmax = plogis(`0.975quant`), y = type, colour = type
    )
  ) +
  geom_errorbarh(position = position_dodge(width = 0.5)) +
  geom_vline(xintercept = 0.5, linetype = 2) +
  geom_vline(xintercept = c(0.25, 0.75), linetype = 3) +
  geom_point() +
  scale_x_continuous(
    "kans op voorkeur voor index", labels = label_percent(), limits = 0:1
  ) +
  scale_y_discrete(limits = rev(c("gemiddelde", levels(background$type)))) +
  theme(axis.title.x = element_text())
```

## Het gebruik van referentielijnen op de grafiek

Na de schaal van de Y-as bieden we de deelnemer de keuze tussen drie opties voor referentielijnen: 1) geen referentielijnen, 2) enkel de referentielijnen en 3) geannoteerde referentielijnen.
We illustreren de mogelijkheden in figuur \@ref(fig:referentie-sterk).
Merk op dat we het type "index" gebruiken voor de Y-as.
Tijdens de bevraging kreeg elke deelnemer de geselecteerde Y-as uit de vorige vraag.

De lijn "referentie" verwijst naar een relevant referentieniveau dat te kiezen is door de maker van de figuur.
Een logische keuze de toestand in een bepaald referentiejaar.
Een andere mogelijkheid is het niveau van een bepaalde doelstelling uit een beleidsplan.
Daarnaast gebruiken we nog twee bijkomende lijnen: "belangrijke toename" en "belangrijke afname".
Deze lijnen kunnen de lezer van de figuur helpen bij de interpretatie.
Het is aan betrokken expert om te bepalen wat een "belangrijke toename" en "belangrijke afname" is én om deze keuze te motiveren.
Vaak kan de expert een van beiden bepalen.
Gebruik in dat geval het tegengestelde effect voor de andere lijn.
Stel dat de expert stelt dat -50% (een halvering) een belangrijke afname is.
Het tegengestelde effect is dan +100% (een verdubbeling).

Een bijkomend voordeel van het weergeven van een belangrijke toename en afname is dat we vermijden van te sterk in te zoomen wanneer enkel beperkte verschillen aanwezig zijn.
We illustreren dit in figuur \@ref(fig:referentie-matig).
Merk op dat de deelfiguur zonder referentielijnen sterkere verschillen lijkt te vertonen dan de andere figuren, hoewel alle figuren dezelfde tijdreeks tonen.

```{r referentie-sterk, fig.cap = "Keuzemogelijkheden voor de referentie met een sterke trend als voorbeeld.", fig.height = 5}
grid.arrange(
  create_figure(dataset = ds) +
    ggtitle("geen"),
  create_figure(dataset = ds, reference = "lines") +
    ggtitle("lijnen"),
  create_figure(dataset = ds, reference = "lines + text") +
    ggtitle("geannoteerde lijnen") +
    geom_blank(data = data.frame(x = max(ds$x), mu = 1.45)),
  ncol = 1
)
```

```{r referentie-matig, fig.cap = "Keuzemogelijkheden voor de referentie met een matige trend als voorbeeld.", fig.height = 5}
ds_moderate <- generate_data(size = "moderate")
grid.arrange(
  create_figure(dataset = ds_moderate) +
    ggtitle("geen"),
  create_figure(dataset = ds_moderate, reference = "lines") +
    ggtitle("lijnen"),
  create_figure(dataset = ds_moderate, reference = "lines + text") +
    ggtitle("geannoteerde lijnen") +
    geom_blank(data = data.frame(x = max(ds$x), mu = 1.45)),
  ncol = 1
)
```

In tabel \@ref(tab:referentie) geven we een overzicht van de waargenomen voorkeuren.
De voorkeur verschilt naargelang de voorkennis van de deelnemers en de sterkte van de trend (fig. \@ref(fig:referentie-model)).
Globaal kunnen we stellen dat er een duidelijke voorkeur is voor referentielijnen, zeker wanneer we deze expliciet benoemen in de figuur.
Deelnemers uit de groep "weinig vertrouwd" verkiezen vaker om geen referentielijnen te zien.
Zeker bij een matige trend zagen we fenomeen.
Bij dergelijke figuren zijn de referentielijnen met een belangrijke toename of afname extremer dan de trendreeks.
Hierdoor toont de trendreeks in de figuur een minder sterke schommeling.

```{r referentie}
reference |>
  inner_join(background, by = "id") |>
  count(.data$referentie, .data$trend, .data$type) |>
  pivot_wider(
    names_from = "type", names_sort = TRUE, values_from = "n", values_fill = 0
  ) %>%
  bind_rows(
    summarise(
      ., referentie = "totaal", trend = "",
      across(-c("referentie", "trend"), sum)
    )
  ) %>%
  bind_cols(
    select(., -c("referentie", "trend")) %>%
      transmute(totaal = pmap_dbl(., sum))
  ) |>
  kbl(
    caption = "Voorkeur voor referentielijnen per type deelnemer.",
    align = "llrrrr", booktabs = TRUE
  ) |>
  row_spec(c(2, 4, 6), hline_after = TRUE) |>
  row_spec(7, bold = TRUE) |>
  column_spec(6, bold = TRUE)
```

```{r referentie-model-fit}
reference |>
  inner_join(background, by = "id") |>
  count(.data$type, .data$referentie, .data$trend) |>
  complete(
    .data$type, .data$referentie, .data$trend, fill = list(n = 0)
  ) -> ds_referentie
m_type_trend <- inla(
  n ~ 0 + referentie + referentie:type + referentie:trend, family = "poisson",
  data = ds_referentie, control.compute = list(waic = TRUE, config = TRUE)
)
```

```{r referentie-modelbouw, eval = FALSE}
m0 <- inla(
  n ~ 0 + referentie, family = "poisson", data = ds_referentie,
  control.compute = list(waic = TRUE)
)
m_type <- inla(
  n ~ 0 + referentie + referentie:type, family = "poisson",
  data = ds_referentie, control.compute = list(waic = TRUE)
)
m_trend <- inla(
  n ~ 0 + referentie + referentie:trend, family = "poisson",
  data = ds_referentie, control.compute = list(waic = TRUE)
)
m_type_trend <- inla(
  n ~ 0 + referentie + referentie:type + referentie:trend, family = "poisson",
  data = ds_referentie, control.compute = list(waic = TRUE)
)
m_type_trend2 <- inla(
  n ~ 0 + referentie + referentie:type + referentie:trend +
    referentie:type:trend,
  family = "poisson", data = ds_referentie, control.compute = list(waic = TRUE)
)
waic <- c(
  m0$waic$waic, m_type$waic$waic, m_trend$waic$waic, m_type_trend$waic$waic,
  m_type_trend2$waic$waic
)
```

```{r referentie-model, message = FALSE, fig.cap = "Kans dat deelnemers verkiezen om referentielijnen te tonen, al dan niet beschrijvende tekst."}
inla.posterior.sample(n = 1e3, m_type_trend) |>
  map("latent") |>
  map(data.frame) |>
  bind_cols() |>
  rownames_to_column(var = "parameter") |>
  filter(str_detect(.data$parameter, "Predictor")) |>
  bind_cols(
    ds_referentie |>
      select("type", "referentie")
  ) |>
  select(-"parameter") |>
  pivot_longer(
    c(-"type", -"referentie"), names_to = "sim",
    values_to = "estimate"
  ) |>
  group_by(.data$referentie, .data$type, .data$sim) |>
  summarise(
    estimate = mean(.data$estimate) |>
      exp(), .groups = "drop"
  ) |>
  mutate(
    referentie = factor(
      .data$referentie, levels = c("lijn + tekst", "lijn", "geen"),
      labels = c(
        "lijnen\nmet tekst", "lijnen al\ndan niet met\nmet tekst", "geen"
      )
    )
  ) |>
  arrange(.data$referentie) |>
  group_by(.data$type, .data$sim) |>
  mutate(
    estimate = cumsum(.data$estimate) / sum(.data$estimate)
  ) |>
  filter(.data$referentie != "geen") |>
  group_by(.data$type, .data$referentie) |>
  summarise(
    mediaan = median(.data$estimate),
    lcl = quantile(.data$estimate, probs = 0.025),
    ucl = quantile(.data$estimate, probs = 0.975),
    .groups = "drop"
  ) |>
  ggplot(
    aes(x = mediaan, xmin = lcl, xmax = ucl, y = type, colour = referentie)
  ) +
  geom_vline(xintercept = 0.5, linetype = 2) +
  geom_vline(xintercept = c(0.25, 0.75), linetype = 3) +
  geom_errorbarh(position = position_dodge(width = 0.5)) +
  geom_point(position = position_dodge(width = 0.5)) +
  scale_x_continuous(labels = percent, limits = 0:1)
```

## Aanduiding van onzekerheid

We beschouwen in dit geval de onzekerheid ten gevolge van de steekproeftrekking.
Vaak is het onmogelijk om alle elementen van de volledige populatie te meten.
In dat geval maken we gebruik van een zogenaamde steekproef: het gedeelte van de steekproef dat we effectief meten.
We gaan er vanuit dat het om een representatieve steekproef gaat: een deel van de populatie waarvan we verwachten dat ze gelijkaardige kenmerken heeft als de volledige populatie.
Op die manier kunnen de kenmerken van de steekproef gebruiken als een benadering van deze kenmerken voor de volledige populatie.

Telkens we een andere aselecte representatieve steekproef trekken uit de populatie zullen we meestal een iets andere schatting krijgen van het kenmerk waarin we geïnteresseerd zijn.
Er is bijgevolg onvermijdelijk een zekere mate van onzekerheid rond de schatting op basis van een steekproef.
Met statistiek kunnen we op basis van een enkele steekproef inschatten hoe groot deze onzekerheid is, het zogenaamde betrouwbaarheidsinterval.
Kort door de bocht is er 95% kans dat de werkelijke waarde (van de populatie) binnen het 95% betrouwbaarheidsinterval ligt.
Bijgevolg is er 5% kans dat de werkelijke waarde buiten het 95% betrouwbaarsheidsinterval ligt.
Meestal zorgen we dat de grenzen symetrisch zijn zodat er 2.5% kans is dat de werkelijke waarde kleiner is dan het interval en 2.5% kans dat het groter is.

Hoe groter het verschil tussen de onder- en bovengrens van het interval, hoe breder het interval en hoe groter de onzekerheid (en kleiner de precisie).
Hoe meer (niet verklaarde) variabiliteit in de gegevens, hoe breder het betrouwbaarheidsinterval.
Het vergroten dan de steekproef zorgt dan weer voor een smaller betrouwbaarheidsinterval.

Het dekkingspercentage van het betrouwbaarheidsinterval heeft eveneens invloed op de breedte van het interval.
Wanneer een dekking van 90% voldoende is volstaat een smaller interval in vergelijking met een dekking van 95%.
De dekking van het interval aanpassen is een tweesnijdend zwaard.
Vaak vergelijken we de grenzen van het interval met een referentie.
Ligt het interval volledig boven of onder de referentie, dan stellen we dat er een (significant) effect is.
Een lagere dekking geeft een hogere kans op vals positieven.
Op basis van de steekproef stellen we dat er een verschil is, terwijl er op populatieniveau geen verschil is.
Het waargenomen verschil in de steekproef is dan het gevolg van toeval.
Een hogere dekking geeft dan weer een hogere kans op vals negatieven.
Door het brede interval kunnen we het werkelijke verschil in de populatie niet aantonen.

In de ecologie zijn vals positieven meestal veiliger dan vals negatieven.
Bij vals negatieve uitspraken kunnen we bijvoorbeeld te lang blijven veronderstellen dat de toestand voldoende is.
Hierdoor kunnen we te laat beginnen ingrijpen waardoor we drastischere en duurdere maatregelen nodig hebben.
Bij vals positieve uitspraken zullen we mogelijk te snel ingrijpen.
We hebben dan weliswaar onnodig middelen ingezet, doch de inzet zal beperker zijn

We boden de deelnemers drie mogelijkheid aan om de onzekerheid op de trendschatting weer te geven (fig. \@ref(fig:onzekerheid-keuze)): 1) "geen"; 2) band; en 3) "gradient".
Bij "geen" tonen we de onzekerheid rond de geschatte trend niet.
Hoewel dit de eenvoudigste figuur oplevert, bieden we de gebruiker geen inzicht in de onzekerheid rond de geschatte trend.
"Band" is een eenvoudige manier om de onzekerheid weer te geven.
De band geeft de boven- en ondergrens van het 90% betrouwbaarheidsinterval weer.
"Gradient" toont de onzekerheid als een combinatie van drie banden met verschillende transparantie.
De breedste, meest transparante band toont de boven- en ondergrens van het 90% betrouwbaarheidsinterval (net zoals "band").
De smalste, minst transparante band toont de boven- en ondergrens van het 30% betrouwbaarheidsinterval.
De middenste band toont de boven- en ondergrens van het 60% betrouwbaarheidsinterval.
De waarden met een hogere waarschijnlijkheidsdichtheid zijn hierdoor donkerder weergegeven.

```{r onzekerheid-keuze, fig.cap = "Keuzemogelijkheden voor het aangeven van onzekerheid.", fig.height = 5}
ds_potential <- generate_data("potential")
grid.arrange(
  create_figure(dataset = ds_potential, reference = "lines + text") +
    ggtitle("geen") +
    geom_blank(data = data.frame(x = max(ds$x), mu = 1.45)),
  create_figure(
    dataset = ds_potential, reference = "lines + text", ci = "band"
  ) +
    ggtitle("band") +
    geom_blank(data = data.frame(x = max(ds$x), mu = 1.45)),
  create_figure(
    dataset = ds_potential, reference = "lines + text", ci = "gradient"
  ) +
    ggtitle("gradient") +
    geom_blank(data = data.frame(x = max(ds$x), mu = 1.45)),
  ncol = 1
)
```

Tabel \@ref(tab:onzekerheid) geeft een overzicht van de voorkeur van de deelnemers.
Negen op tien van de deelnemers die zich vertrouwd voelen met cijfers verkiezen om de onzekerheid te zien op de figuur \@ref(fig:onzekerheid-model).
Ook bij wie zich minder vertrouwd voelt, geeft driekwart een voorkeur voor de weergave van onzekerheid aan.
Globaal verkiezen de deelnemers de stijl "band" boven "gradient".

```{r onzekerheid}
uncertainty |>
  inner_join(background, by = "id") |>
  count(.data$onzekerheid, .data$trend, .data$type) |>
  pivot_wider(
    names_from = "type", names_sort = TRUE, values_from = "n", values_fill = 0
  ) %>%
  bind_rows(
    summarise(
      ., onzekerheid = "totaal", trend = "",
      across(-c("onzekerheid", "trend"), sum)
    )
  ) %>%
  bind_cols(
    select(., -c("onzekerheid", "trend")) %>%
      transmute(totaal = pmap_dbl(., sum))
  ) |>
  kbl(
    caption = "Voorkeur voor weergave van onzekerheid per type deelnemer.",
    align = "llrrrr", booktabs = TRUE
  ) |>
  row_spec(c(3, 6, 9), hline_after = TRUE) |>
  row_spec(10, bold = TRUE) |>
  column_spec(6, bold = TRUE)
```

```{r onzekerheid-model-fit}
uncertainty |>
  inner_join(background, by = "id") |>
  count(.data$type, .data$onzekerheid, .data$trend) |>
  complete(
    .data$type, .data$onzekerheid, .data$trend, fill = list(n = 0)
  ) -> ds_onzekerheid
m_type_trend <- inla(
  n ~ 0 + onzekerheid + onzekerheid:type + onzekerheid:trend,
  family = "poisson", data = ds_onzekerheid,
  control.compute = list(waic = TRUE, config = TRUE)
)
```

```{r onzekerheid-modelbouw, eval = FALSE}
m0 <- inla(
  n ~ 0 + onzekerheid, family = "poisson", data = ds_onzekerheid,
  control.compute = list(waic = TRUE)
)
m_type <- inla(
  n ~ 0 + onzekerheid + onzekerheid:type, family = "poisson",
  data = ds_onzekerheid, control.compute = list(waic = TRUE)
)
m_trend <- inla(
  n ~ 0 + onzekerheid + onzekerheid:trend, family = "poisson",
  data = ds_onzekerheid, control.compute = list(waic = TRUE)
)
m_type_trend <- inla(
  n ~ 0 + onzekerheid + onzekerheid:type + onzekerheid:trend,
  family = "poisson", data = ds_onzekerheid, control.compute = list(waic = TRUE)
)
m_type_trend2 <- inla(
  n ~ 0 + onzekerheid + onzekerheid:type + onzekerheid:trend +
    onzekerheid:type:trend,
  family = "poisson", data = ds_onzekerheid, control.compute = list(waic = TRUE)
)
waic <- c(
  m0$waic$waic, m_type$waic$waic, m_trend$waic$waic, m_type_trend$waic$waic,
  m_type_trend2$waic$waic
)
```

```{r onzekerheid-model, message = FALSE, fig.cap = "Kans dat deelnemers verkiezen om onzekerheid te tonen, al dan niet als gradient."}
inla.posterior.sample(n = 1e3, m_type_trend) |>
  map("latent") |>
  map(data.frame) |>
  bind_cols() |>
  rownames_to_column(var = "parameter") |>
  filter(str_detect(.data$parameter, "Predictor")) |>
  bind_cols(
    ds_onzekerheid |>
      select("type", "onzekerheid", "trend")
  ) |>
  select(-"parameter") |>
  pivot_longer(
    c(-"type", -"onzekerheid", -"trend"), names_to = "sim",
    values_to = "estimate"
  ) |>
  group_by(.data$type, .data$onzekerheid, .data$sim) |>
  summarise(
    estimate = mean(.data$estimate) |>
      exp(),
    .groups = "drop"
  ) |>
  mutate(
    onzekerheid = factor(
      .data$onzekerheid, levels = c("band", "gradient", "geen"),
      labels = c("band", "band of \ngradient", "geen")
    )
  ) |>
  arrange(.data$onzekerheid) |>
  group_by(.data$type, .data$sim) |>
  mutate(
    estimate = cumsum(.data$estimate) / sum(.data$estimate)
  ) |>
  filter(.data$onzekerheid != "geen") |>
  group_by(.data$type, .data$onzekerheid) |>
  summarise(
    mediaan = median(.data$estimate),
    lcl = quantile(.data$estimate, probs = 0.025),
    ucl = quantile(.data$estimate, probs = 0.975),
    .groups = "drop"
  ) |>
  ggplot(
    aes(x = mediaan, xmin = lcl, xmax = ucl, y = type, colour = onzekerheid)
  ) +
  geom_vline(xintercept = 0.5, linetype = 2) +
  geom_vline(xintercept = c(0.1, 0.9), linetype = 4) +
  geom_vline(xintercept = c(0.25, 0.75), linetype = 3) +
  geom_errorbarh(position = position_dodge(width = 0.5)) +
  geom_point(position = position_dodge(width = 0.5)) +
  scale_x_continuous(labels = percent, limits = 0:1)
```
